generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id               String            @id @default(uuid())
  email            String            @unique
  name             String
  password         String
  createdAt        DateTime          @default(now())
  bookings         Booking[]
  organizerProfile OrganizerProfile?
  reviews          Review[]
  userProfile      UserProfile?
  chatMembers      ChatMember[]
  chatMessages     ChatMessage[]
}

model UserProfile {
  id                String    @id @default(uuid())
  userId            String    @unique
  fullName          String?
  phone             String?
  dateOfBirth       DateTime?
  gender            String?
  profilePictureUrl String?
  createdAt         DateTime  @default(now())
  user              User      @relation(fields: [userId], references: [id])
}

model OrganizerProfile {
  id               String   @id @default(uuid())
  userId           String   @unique
  organizationName String?
  contactNumber    String?
  address          String?
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id])
  events           Event[]
}


model EventImages {
  id        String   @id @default(uuid())
  eventId   String
  imageUrl  String
  createdAt DateTime @default(now())
  event     Event    @relation(fields: [eventId], references: [id])
}

model Event {
  id          String        @id @default(uuid())
  title       String
  description String
  date        DateTime
  location    String
  capacity    Int
  price       Float
  mood        String?
  organizerId String?
  createdAt   DateTime      @default(now())
  bookings    Booking[]
  images      EventImages[]
  reviews     Review[]
  chatRoom    ChatRoom?
  organizer   OrganizerProfile? @relation(fields: [organizerId], references: [id])
}

model Booking {
  id           String   @id @default(uuid())
  userId       String
  eventId      String
  ticketCounts Int
  unitPrice    Float?
  totalPrice   Float?
  status       Status
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  event        Event    @relation(fields: [eventId], references: [id])
  user         User     @relation(fields: [userId], references: [id])
}

model Review {
  id              String          @id @default(uuid())
  userId          String
  eventId         String
  rating          Int
  comment         String?
  sentimentStatus SentimentStatus @default(PENDING)
  sentimentLabel  String?
  sentimentScore  Float?
  createdAt       DateTime        @default(now())
  upatedAt        DateTime        @updatedAt
  event           Event           @relation(fields: [eventId], references: [id])
  user            User            @relation(fields: [userId], references: [id])
  sentimentJob    SentimentJob?
}

model SentimentJob {
  id        String    @id @default(uuid())
  reviewId  String    @unique
  status    JobStatus @default(PENDING)
  attempts  Int       @default(0)
  error     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  review    Review    @relation(fields: [reviewId], references: [id])
}

model ChatRoom {
  id        String        @id @default(uuid())
  eventId   String        @unique
  createdAt DateTime      @default(now())
  event     Event         @relation(fields: [eventId], references: [id])
  members   ChatMember[]
  messages  ChatMessage[]
}

model ChatMember {
  id         String   @id @default(uuid())
  chatRoomId String
  userId     String
  joinedAt   DateTime @default(now())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([chatRoomId, userId])
}

model ChatMessage {
  id         String   @id @default(uuid())
  chatRoomId String
  senderId   String
  content    String
  createdAt  DateTime @default(now())
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id])
  sender     User     @relation(fields: [senderId], references: [id])
}

enum SentimentStatus {
  PENDING
  ANALYZED
  FAILED
}

enum JobStatus {
  PENDING
  PROCESSING
  DONE
  FAILED
}

enum Status {
  PENDING
  CONFIRMED
  CANCELLED
}
